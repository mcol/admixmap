/*         DO NOT EDIT THIS FILE!!        */
/* -- AUTOGENERATED FROM *_source FILE -- */
// matrix_d.h
#ifndef MATRIX_MATRIX_d_H
#define MATRIX_MATRIX_d_H 1

#include <iostream>
#include <iomanip>
#include <cassert>

#include <gsl/gsl_math.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_blas_types.h>
#include <gsl/gsl_blas.h>
#include <gsl/gsl_ieee_utils.h>
#include <gsl/gsl_eigen.h>

#include <vector>

class Vector;
class Vector_d;
class Vector_i;

class Matrix;
class Matrix_d;
class Matrix_i;

class Matrix_d
{
 private: // members
  std::vector<size_t> _MissingCol;
  std::vector<size_t> _MissingRow;
  gsl_matrix * _matrix;
  
  // GLOBAL FRIENDS
  friend Matrix_d
    ConcatenateHorizontally( const Matrix_d& m1, const Matrix_d& m2 );

  friend std::ostream&
    operator<< ( std::ostream& os, const Matrix_d& M );

  friend void
    operator>> ( const char * FileName, Matrix_d& M );

  friend Matrix_d
    operator*( double, const Matrix_d& m);

 public:
  // CONSTRUCTORS
  // default constructor
  Matrix_d();

  // copy constructor
  Matrix_d(const Matrix_d& M);

  // number of rows and columns
  Matrix_d(size_t NewRows, size_t NewCols);


  // DESTRUCTOR
  ~Matrix_d();


  // ASSIGNMENT OPERATORS
  Matrix_d&
    operator=(const Matrix& m);

  Matrix_d&
    operator=(const Matrix_d& m);

  Matrix_d&
    operator=(const Matrix_i& m);

  
  // CONVERTERS
  Matrix_d
    Double() const;

  Matrix
    Float() const;

  Matrix_i
    Integer() const;


  // OPERATORS
  double&
     operator()(int row, int col);

  double&
     operator()(int row, int col) const;

  Matrix_d
    operator+(double f) const;

  Matrix_d
    &operator*=(const double f);

  Matrix_d
    operator+(const Matrix& m) const;

  Matrix_d
    operator+(const Matrix_i& m) const;

  Matrix_d
    operator+(const Matrix_d& m) const;

  Matrix_d&
    operator+=(const Matrix_d& m);

  Matrix_d
    operator-(const Matrix_d& m) const;

  Matrix_d
    operator*(double f) const;

  Matrix_d
    operator*(const Matrix_d& m) const;

  Matrix_d
    operator/(double) const;

  Matrix_d&
    operator/=(double);

  // ACCESSORS
  
  Vector_d
    GetColumn(int col) const;

  void
    SetColumn(int col, const Vector_d& v);

  Vector_d
    GetDiagonal() const;

  void
    SetDiagonal(double);
  
  void
    SetElements(double NewValue);

  void
    SetMissingElement(int row, int col);

  bool
    IsMissingValue(int row, int col) const;

  int
    GetMissingValueCol(int index) const;

  int
    GetMissingValueRow(int index) const;

  int
    GetNumberOfCols() const;

  int
    GetNumberOfRows() const;

  void
    SetNumberOfElements(size_t NewRows, size_t NewCols);

  int
    GetNumberOfMissingValues() const;

  Vector_d
    GetRow(int row) const;

  void
    SetRow(int row, const Vector_d& v);


  
  // FILE ACCESS
  void
    Load( const char *FileName );



  // OBJECT METHODS
  int
    CholeskyDecomposition(Matrix_d*) const;

  Vector_d
    ColumnMean() const;

  double
    Determinant() const;

  void
    Eigenvalue2(Vector_d*);

  Matrix_d
    FindElement( double );
  
  void
    InvertUsingLUDecomposition();

  double
    LogDeterminant( int *sign ) const;

  Vector_d
    RowMean() const;

  Vector_d
    RowSum() const;

  void
    SetMissingValuesToColumnMeans();

  Matrix_d
    SubMatrix( int rowstart, int rowfinish,
	       int colstart, int colfinish) const;   
  
  void
    SubMatrix2(int rowstart, int rowfinish,
	       int colstart, int colfinish);   
  
  void
    Symmetrize();
  
  Matrix_d
    Transpose() const;
  
  bool
    IsSymmetric() const;

 private:

  // PRIVATE HELPER METHODS
  Vector_d
    ColumnSum() const;

  Vector_d
    ColumnMeanExcludingMissingValues() const;

  Vector_d
    ColumnSumExcludingMissingValues() const;

  double
    LU_lndet();

  int
    LU_decomp (gsl_permutation * p);
};

#endif /* !defined MATRIX_MATRIXdouble_H */
