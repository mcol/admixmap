// *-*-C++-*-*
#ifndef LSHTM_MATRIX_H
#define LSHTM_MATRIX_H 1
#include <lshtm/bits/minmax.h>
#include <lshtm/Vector>

#include <cstdlib>
#include <cassert>
#include <cstddef>

namespace lshtm
{

  template<class T>
  class Matrix
  {
  private:
    size_t _rows;
    size_t _cols;


  protected:
    T* _data;

  public:
    /**
     * Default constructor, which constructs a matrix with zero rows and columns
     */
    Matrix():
      _rows(0),
      _cols(0),
      _data(0)
    {}

    /**
     * Constructs a matrix with n rows and m columns. If the third
     * argument is not supplied, value is obtained with the default
     * constructor T(), for the element value type T.
     */
    Matrix(size_t n, size_t m, const T& value = T()):
      _rows(n),
      _cols(m),
      _data(static_cast<T*>(malloc(n*m*sizeof(T))))
    {
      using namespace std;
      assert(_data);

      for(size_t i=0; i<n*m; i++){
	_data[i] = value;
      }
    }
  
    /**
     * Matrix copy constructor, which constructs a matrix, and
     * initializes it with copies of the elements of Matrix x.
     */
    Matrix(const Matrix<T>& x):
      _rows(x._rows),
      _cols(x._cols),
      _data(static_cast<T*>(malloc(x._rows*x._cols*sizeof(T))))
    {
      using namespace std;
      assert(_data);

      for(size_t i=0; i<x._rows*x._cols; i++){
	_data[i] = x._data[i];
      }
    }

    /**
     * Templated copy constructor, which constructs a matrix, and
     * initializes it with copies of the elements of Matrix x.
     */
    template<class U>
    Matrix(const Matrix<U>& x):
      _rows(x.rows()),
      _cols(x.cols()),
      _data(static_cast<T*>(malloc(x.rows() * x.cols() * sizeof(T))))
    {
      using namespace std;
      assert(_data);

      for(size_t row=0; row<_rows; row++){
	size_t offset = row*_cols;
	for(size_t col=0; col<_cols; col++){
	  _data[offset + col] = static_cast<T>(x(row,col));
	}
      }
    }

    /**
     * Matrix assignment operator. Replaces the contents of the
     * current Matrix with a copy of the parameter Matrix x.
     */
    Matrix<T>& operator=(const Matrix<T>& x)
    {
      using namespace std;
      if(this == &x){
	return *this;
      }
      free(_data);
      _data = static_cast<T*>(malloc(x._rows*x._cols*sizeof(T)));
      assert(_data);

      _rows = x.rows();
      _cols = x.cols();
      for(size_t i=0; i<_rows*_cols; i++){
	_data[i] = x._data[i];
      }

      return *this;
    }
  
    /**
     * Templated assignment operator. Replaces the contents of the
     * current Matrix with a copy of the parameter Matrix x.
     */
    template<class U>
    Matrix<T>& operator=(const Matrix<U>& x)
    {
      using namespace std;
      if(static_cast<void*>(this) == static_cast<const void*>(&x)){
	return *this;
      }
      free(_data);
      _data = static_cast<T*>(malloc(x.rows()*x.cols()*sizeof(T)));
      assert(_data);
      
      _rows = x.rows();
      _cols = x.cols();
      for(size_t row=0; row<_rows; row++){
	size_t offset = row*_cols;
	for(size_t col=0; col<_cols; col++){
	  _data[offset + col] = static_cast<T>(x(row,col));
	}
      }
      
      return *this;
    }

    /**
     * Makes the Matrix contain n rows and m columns of
     * the value u.
     */
    void assign(size_t n, size_t m, const T& u)
    {
      using namespace std;
      free(_data);
      _data = static_cast<T*>(malloc(n*m*sizeof(T)));
      assert(_data);

      for(size_t i=0; i<n*m; i++){
	_data[i] = u;
      }
      _rows = n;
      _cols = m;
    }
  
    /**
     * Matrix destructor
     */
    ~Matrix(){ free(_data); }

    /**
     * Swaps the contents of the current Matrix with those of
     * the input Matrix x. The current Matrix replaces x and
     * vice versa.
     */
    void swap(Matrix<T>& x)
    {
      T* temp_data     = _data;
      size_t temp_rows = _rows;
      size_t temp_cols = _cols;
      
      _data = x._data;
      _rows = x._rows;
      _cols = x._cols;

      x._data = temp_data;
      x._rows = temp_rows;
      x._cols = temp_cols;
    }

    /**
     * Equality operation on Matrices. Returns true if the
     * elements in x and y are equal (using T::operator=).
     * Takes linear time.
     */
    friend bool
    operator==(const Matrix<T>& x, const Matrix<T>& y)
    {
      if(&x == &y){
	return true;
      }
      
      if((x._rows == y._rows) && (x._cols = y._cols)){
	for(size_t i=0; i<x._rows * x._cols; i++){
	  if(x._data[i] != y._data[i]){
	    return false;
	  }
	}
      } else {
	return false;
      }
      
      return true;
    }
  
    /**
     * Returns the number of elements currently stored in
     * the Matrix.
     */
    size_t size() const { return _rows * _cols; }

    /**
     * Returns the number of rows in the Matrix.
     */
    size_t rows() const { return _rows; }

    /**
     * Returns the number of columns in the Matrix.
     */
    size_t cols() const { return _cols; }

    /**
     * Resizes the Matrix to have n rows and m columns by either
     * inserting copies of c on the end or erasing elements from
     * the end.
     */

    //? DANGER - this doesn't work
    // it changes the dimensions _rows and _cols
    // without sensibly copying the contents

    void resize(size_t n, size_t m, T c = T())
    {
      using namespace std;

      if(n==0 || m==0){

	// zero-sized matrix
	free(_data);
	_data = 0;

      } else {
	if(empty()){

	  // no previous data to worry about
	  _data = static_cast<T*>(malloc(n*m*sizeof(T)));
	  assert(_data);
	  for(size_t i=0; i<n*m; i++){
	    _data[i] = c;
	  }

	} else {
	  if(m != _cols){

	    // column count has changed
	    // previous array must be replaced
	    T* new_data = static_cast<T*>(malloc(n*m*sizeof(T)));
	    assert(new_data);

	    for(size_t i=0; i<n*m; i++){
	      new_data[i] = c;
	    }

	    size_t rows2copy = n>_rows ? _rows : n; /* min(n,_rows) */
	    size_t cols2copy = m>_cols ? _cols : m; /* min(m,_cols) */

	    for(size_t row=0; row<rows2copy; row++){
	      for(size_t col=0; col<cols2copy; col++){
		new_data[row*m + col] = _data[row*_cols + col];
	      }
	    }
	    free(_data);
	    _data = new_data;

	  } else {

	    // column count has not changed
	    // previous array can be resized
	    _data = static_cast<T*>(realloc(_data,n*_cols*sizeof(T)));
	    assert(_data);
	    if (n>_rows){
	      for(size_t row=_rows; row<n; row++){
		for(size_t col=0; col<_cols; col++){
		  _data[row*_cols + col] = c;
		}
	      }
	    }

	  }
	}
      }
      _rows = n;
      _cols = m;
    }

    /**
     * Returns true if the Matrix contains no elements
     * (i.e. there are zero rows, columns or both).
     */
    bool empty() const
    {
      return (_rows==0 || _cols==0);
    }


    /**
     * returns the element on the nth row and mth column
     * in constant time
     */
    T& operator()(size_t n,size_t m)
    {
      return _data[n*_cols + m];
    }
    T operator()(size_t n,size_t m) const
    {
      return _data[n*_cols + m];
    }
    T& at(size_t n,size_t m)
    {
      assert(n<_rows && m<_cols);
      return _data[n*_cols + m];
    }
    T at(size_t n,size_t m) const
    {
      assert(n<_rows && m<_cols);
      return _data[n*_cols + m];
    }

    /**
     * erases all elements in the matrix.
     */
    void clear()
    {
      free(_data);
      _data = 0;
      _rows = 0;
      _cols = 0;
    }

    /**
     * FROM GSL MATRIX LIBRARIES
     */

    // GSL manual, section 8.4.3

    /**
     * Sets all elements of the matrix to the value x.
     */
    void set_all(T x)
    {
      for(size_t i=0; i<_rows*_cols; i++){
	_data[i] = x;
      }
    }
  
    /**
     * Sets all elements of the matrix to zero.
     */
    void zero()
    {
      set_all(T());
    }
  
    /**
     * Sets the elements of the Matrix to the corresponding
     * elements of the identity matrix, i.e. a unit diagonal
     * with all off-diagonal elements zero. This applies to both
     * square and rectangular matrices.
     */
    void set_identity()
    {
      for(size_t row=0; row<_rows; row++){
	for(size_t col=0; col<_cols; col++){
	  if(row==col){
	    _data[row*_cols + col] = 1;
	  } else {
	    _data[row*_cols + col] = 0;
	  }
	}
      }
    }

    // GSL manual, section 8.4.6

    /**
     * Returns the submatrix that is bounded by the rows k1 and 
     * k2, and by the columns n1 and n2 inclusive.
     */
    Matrix<T> submatrix(size_t k1, size_t k2, size_t n1, size_t n2) const
    {
      using namespace std;
      assert(k1<_rows && k2<_rows && n1<_cols && n2<_cols);

      size_t row_start  = k1<k2 ? k1 : k2;
      size_t row_finish = k1<k2 ? k2 : k1;

      size_t col_start  = n1<n2 ? n1 : n2;
      size_t col_finish = n1<n2 ? n2 : n1;
 
      Matrix<T> subm((row_finish+1)-row_start,
		     (col_finish+1)-col_start);
      size_t sub_row = 0;
      for(size_t row=row_start; row<=row_finish; row++){
	size_t sub_col = 0;
	for(size_t col=col_start; col<=col_finish; col++){
	  subm(sub_row,sub_col) = (*this)(row,col);
	  sub_col++;
	}
	sub_row++;
      }
      return subm;
    }

    /**
     * Returns a matrix containing the diagonal elements
     * of the Matrix. The matrix is not required to be square.
     */
    Vector<T> diagonal() const
    {
      size_t diag = _rows>_cols ? _cols : _rows; /* min(_rows,_cols) */
      Vector<T> result(diag);
      for(size_t i=0; i<diag; i++){
	result[i] = (*this)(i,i);
      }
      return result;
    }

    void diagonal(T x){
      size_t diag = _rows>_cols ? _cols : _rows; /* min(_rows,_cols) */
      for(size_t i=0; i<diag; i++){
	(*this)(i,i) = x;
      }
    }

    // GSL manual, section 8.4.8

    /**
     * Copies the elements of the i-th row into a Vector
     */
    Vector<T> row(size_t i) const
    {
      assert(i<_rows);
      Vector<T> v(_cols);
      size_t offset = i*_cols;
      for(size_t elem=0; elem<_cols; elem++){
	v[elem] = _data[offset + elem];
      }
      return v;
    }

    /**
     * Copies the elements of a Vector into the i-th row
     */
    void row(size_t i, Vector<T> v)
    {
      assert(i<_rows && v.size() == _cols);
      size_t offset = i*_cols;
      for(size_t col=0; col<_cols; col++){
	_data[offset + col] = v[col];
      }
    }

    /**
     * Copies the elements of the i-th column into a Vector
     */
    Vector<T> col(size_t i) const
    {
      assert(i<_cols);
      Vector<T> v(_rows);
      size_t elem=0;
      size_t size = size();
      for(size_t offset=i; offset<size; offset+=_cols){
	v[elem] = _data[offset];
	elem++;
      }
      return v;
    }

    /**
     * Copies the elements of a Vector into the i-th column
     */
    void col(size_t i, Vector<T> v)
    {
      assert(i<_cols && v.size() == _rows);
      size_t elem=0;
      size_t size = size();
      for(size_t offset=i; offset<size; offset+=_cols){
	_data[offset] = v[elem];
	elem++;
      }
    }


    // 8.4.9 exchanging rows and columns
    void swap_rows(size_t i, size_t j)
    {
      using namespace std;
      assert(i<_rows && j<_rows);

      if(i==j){
	return;
      }

      T temp_row[_cols];
      for(size_t col=0; col<_cols; col++){
	temp_row[col] = _data[i*_cols + col];
	_data[i*_cols + col] = _data[j*_cols + col];
	_data[j*_cols + col] = temp_row[col];
      }
    }

    void swap_cols(size_t i, size_t j)
    {
      using namespace std;
      assert(i<_cols && j<_cols);

      if(i==j){
	return;
      }

      T temp_col[_rows];
      for(size_t row=0; row<_rows; row++){
	temp_col[row] = _data[row*_cols + i];
	_data[row*_cols + i] = _data[row*_cols + j];
	_data[row*_cols + j] = temp_row[row];
      }
    }

    // GSL manual, section 8.4.10

    template<class U>
    friend Matrix<T> operator+(const U x, const Matrix<T>& m)
    {
      Matrix<T> result = m;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x + result(row,col));
	}
      }
      return result;
    }

    Matrix<T> operator+(const Matrix<T>& m) const
    {
      using namespace std;
      assert(_rows == m.rows() && _cols == m.cols());
      
      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = result(row,col) + m(row,col);
	}
      }
      return result;
    }
    
    template<class U>
    Matrix<T> operator+(const U x) const
    {
      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x + result(row,col));
	}
      }
      return result;
    }

    template<class U>
    Matrix<T>& operator+=(const Matrix<U>& m)
    {
      using namespace std;
      assert(_rows == m.rows() && _cols == m.cols());
      
      for(size_t row=0; row<_rows; row++){
	for(size_t col=0; col<_cols; col++){
	  (*this)(row,col) = static_cast<T>((*this)(row,col) + m(row,col));
	}
      }
      return *this;
    }

    template<class U>
    Matrix<T>& operator+=(U const x)
    {
      for(size_t i=0; i<_rows*_cols; i++){
	_data[i] = static_cast<T>(_data[i] + x);
      }
      return *this;
    }

    template<class U>
    friend Matrix<T> operator-(const U x, const Matrix<T>& m)
    {
      Matrix<T> result = m;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x - result(row,col));
	}
      }
      return result;
    }

    Matrix<T> operator-(const Matrix<T>& m) const
    {
      using namespace std;
      assert(_rows == m.rows() && _cols == m.cols());

      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = result(row,col) - m(row,col);
	}
      }
      return result;
    }

    template<class U>
    Matrix<T> operator-(const U x) const
    {
      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x - result(row,col));
	}
      }
      return result;
    }

    template<class U>
    Matrix<T>& operator-=(const Matrix<U>& m)
    {
      using namespace std;
      assert(_rows == m.rows() && _cols == m.cols());
      
      for(size_t row=0; row<_rows; row++){
	for(size_t col=0; col<_cols; col++){
	  (*this)(row,col) = static_cast<T>((*this)(row,col) - m(row,col));
	}
      }
      return *this;
    }

    template<class U>
    Matrix<T>& operator-=(U const x)
    {
      for(size_t i=0; i<_rows*_cols; i++){
	_data[i] = static_cast<T>(_data[i] - x);
      }
      return *this;
    }
    
    template<class U>
    friend Matrix<T> operator*(const U x, const Matrix<T>& m)
    {
      Matrix<T> result = m;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x * result(row,col));
	}
      }
      return result;
    }
    
    Matrix<T> operator*(const Matrix<T>& m) const
    {
      using namespace std;
      assert(cols() == m.rows());

      Matrix<T> result(rows(),m.cols());
      for(size_t i=0; i<rows(); i++){
	for(size_t j=0; j<m.cols(); j++){
	  for(size_t k=0; k<m.rows(); k++){
	    result(i,j) += (*this)(i,k) * m(k,j);
	  }
	}
      }
      return result;
    }

    template<class U>
    Matrix<T> operator*(const U x) const
    {
      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x * result(row,col));
	}
      }
      return result;
    }

    template<class U>
    Matrix<T>& operator*=(const Matrix<U>& m)
    {
      Matrix<T> result = (*this) * m;
      *this = result;
      return *this;
    }

    template<class U>
    Matrix<T>& operator*=(U const x)
    {
      Matrix<T> result = (*this) * x;
      *this = result;
      return *this;
    }

    template<class U>
    friend Matrix<T> operator/(const U x, const Matrix<T>& m)
    {
      Matrix<T> result = m;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(x / result(row,col));
	}
      }
      return result;
    }

    Matrix<T> operator/(const Matrix<T>& m) const
    {
      using namespace std;
      assert(_rows == m.rows() && _cols == m.cols());

      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = result(row,col) / m(row,col);
	}
      }
      return result;
    }

    template<class U>
    Matrix<T> operator/(const U x) const
    {
      Matrix<T> result = *this;
      for(size_t row=0; row<result.rows(); row++){
	for(size_t col=0; col<result.cols(); col++){
	  result(row,col) = static_cast<T>(result(row,col) / x);
	}
      }
      return result;
    }

    template<class U>
    Matrix<T>& operator/=(const Matrix<U>& m)
    {
      using namespace std;
      assert(_rows == m.rows() && _cols == m.cols());
      
      for(size_t row=0; row<_rows; row++){
	for(size_t col=0; col<_cols; col++){
	  (*this)(row,col) = static_cast<T>((*this)(row,col) / m(row,col));
	}
      }
      return *this;
    }

    template<class U>
    Matrix<T>& operator/=(U const x)
    {
      assert(x!=static_cast<T>(0.0));
      for(size_t i=0; i<_rows*_cols; i++){
	_data[i] = static_cast<T>(_data[i] / x);
      }
      return *this;
    }

    // GSL manual, section 8.4.11

    /**
     * finds the largest element of a matrix
     */
    T max() const
    {
      T max = 0;
      max = lshtm_type_min(max);

      for (size_t row=0; row<_rows; row++){
	for (size_t col=0; col<_cols; col++){
	  if(max < _data[row*_cols + col]){
	    max = _data[row*_cols + col];
	  }
	}
      }
      return max;
    }

    /**
     * finds the smallest element of a matrix
     */
    T min() const
    {
      T min = 0;
      min = lshtm_type_max(min);

      for (size_t row=0; row<_rows; row++){
	for (size_t col=0; col<_cols; col++){
	  if(min > _data[row*_cols + col]){
	    min = _data[row*_cols + col];
	  }
	}
      }
      return min;
    }
  };
}
#endif /* !defined LSHTM_MATRIX_H */
